"use strict";
/** @module @twilio-labs/serverless-api */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const events_1 = __importDefault(require("events"));
const got_1 = __importDefault(require("got"));
const assets_1 = require("./api/assets");
const builds_1 = require("./api/builds");
const dependencies_1 = require("./api/dependencies");
const environments_1 = require("./api/environments");
const functions_1 = require("./api/functions");
const services_1 = require("./api/services");
const variables_1 = require("./api/variables");
const consts_1 = require("./types/consts");
const fs_1 = require("./utils/fs");
const logs_1 = require("./streams/logs");
const logs_2 = require("./api/logs");
const log = debug_1.default('twilio-serverless-api:client');
function createGotClient(config) {
    // @ts-ignore
    const client = got_1.default.extend({
        baseUrl: 'https://serverless.twilio.com/v1',
        json: true,
        auth: `${config.accountSid}:${config.authToken}`,
        headers: {
            'User-Agent': 'twilio-serverless-api',
        },
    });
    return client;
}
exports.createGotClient = createGotClient;
class TwilioServerlessApiClient extends events_1.default.EventEmitter {
    constructor(config) {
        debug_1.default.enable(process.env.DEBUG || '');
        super();
        this.config = config;
        this.client = createGotClient(config);
    }
    /**
     * Returns the internally used GotClient instance used to make API requests
     * @returns {GotClient} A client instance with set-up credentials
     */
    getClient() {
        debug_1.default.enable(process.env.DEBUG || '');
        return this.client;
    }
    /**
     * Returns an object containing lists of services, environments, variables
     * functions or assets, depending on which have beeen requested in `listConfig`
     * @param  {ListConfig} listConfig Specifies info around which things should be listed
     * @returns Promise<ListResult> Object containing the different lists.
     */
    list(listConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            let { types, serviceSid, serviceName: serviceName, environment: environmentSid, } = listConfig;
            if (types === 'services' ||
                (types.length === 1 && types[0] === 'services')) {
                const services = yield services_1.listServices(this.client);
                return { services };
            }
            if (typeof serviceSid === 'undefined' &&
                typeof serviceName !== 'undefined') {
                serviceSid = yield services_1.findServiceSid(serviceName, this.client);
            }
            if (typeof serviceSid === 'undefined') {
                throw new Error('Missing service SID argument');
            }
            const result = {};
            let currentBuildSidForEnv;
            let currentBuild;
            for (const type of types) {
                try {
                    if (type === 'environments') {
                        result.environments = yield environments_1.listEnvironments(serviceSid, this.client);
                    }
                    if (type === 'builds') {
                        result.builds = yield builds_1.listBuilds(serviceSid, this.client);
                    }
                    if (typeof environmentSid === 'string') {
                        if (!environments_1.isEnvironmentSid(environmentSid)) {
                            const environment = yield environments_1.getEnvironmentFromSuffix(environmentSid, serviceSid, this.client);
                            environmentSid = environment.sid;
                            currentBuildSidForEnv = environment.build_sid;
                        }
                        else if (!currentBuildSidForEnv) {
                            const environment = yield environments_1.getEnvironment(environmentSid, serviceSid, this.client);
                            currentBuildSidForEnv = environment.build_sid;
                        }
                        if (type === 'functions' || type === 'assets') {
                            if (!currentBuild) {
                                currentBuild = yield builds_1.getBuild(currentBuildSidForEnv, serviceSid, this.client);
                            }
                            if (type === 'functions') {
                                result.functions = {
                                    environmentSid,
                                    entries: currentBuild.function_versions,
                                };
                            }
                            else if (type === 'assets') {
                                result.assets = {
                                    environmentSid,
                                    entries: currentBuild.asset_versions,
                                };
                            }
                        }
                        if (type === 'variables') {
                            result.variables = {
                                entries: yield variables_1.listVariablesForEnvironment(environmentSid, serviceSid, this.client),
                                environmentSid,
                            };
                        }
                    }
                }
                catch (err) {
                    log(err);
                }
            }
            return result;
        });
    }
    getLogsStream(logsConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            let { serviceSid, environment, filterByFunction } = logsConfig;
            if (!environments_1.isEnvironmentSid(environment)) {
                const environmentResource = yield environments_1.getEnvironmentFromSuffix(environment, serviceSid, this.client);
                environment = environmentResource.sid;
            }
            if (filterByFunction && !functions_1.isFunctionSid(filterByFunction)) {
                const availableFunctions = yield functions_1.listFunctionResources(serviceSid, this.client);
                const foundFunction = availableFunctions.find(fn => fn.friendly_name === filterByFunction);
                if (!foundFunction) {
                    throw new Error('Invalid Function Name or SID');
                }
                filterByFunction = foundFunction.sid;
            }
            const logsStream = new logs_1.LogsStream(environment, serviceSid, this.client, logsConfig);
            return logsStream;
        });
    }
    getLogs(logsConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            let { serviceSid, environment, filterByFunction } = logsConfig;
            if (!environments_1.isEnvironmentSid(environment)) {
                const environmentResource = yield environments_1.getEnvironmentFromSuffix(environment, serviceSid, this.client);
                environment = environmentResource.sid;
            }
            if (filterByFunction && !functions_1.isFunctionSid(filterByFunction)) {
                const availableFunctions = yield functions_1.listFunctionResources(serviceSid, this.client);
                const foundFunction = availableFunctions.find(fn => fn.friendly_name === filterByFunction);
                if (!foundFunction) {
                    throw new Error('Invalid Function Name or SID');
                }
                filterByFunction = foundFunction.sid;
            }
            try {
                return logs_2.listOnePageLogResources(environment, serviceSid, this.client, {
                    pageSize: 50,
                    functionSid: filterByFunction,
                });
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * "Activates" a build by taking a specified build SID or a "source environment"
     * and activating the same build in the specified `environment`.
     *
     * Can optionally create the new environment when called with `activateConfig.createEnvironment`
     * @param  {ActivateConfig} activateConfig Config to specify which build to activate in which environment
     * @returns Promise<ActivateResult> Object containing meta information around deployment
     */
    activateBuild(activateConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            let { buildSid, targetEnvironment, serviceSid, sourceEnvironment, } = activateConfig;
            if (!buildSid && !sourceEnvironment) {
                const error = new Error('You need to specify either a build SID or source environment to activate');
                error.name = 'activate-missing-source';
                throw error;
            }
            if (!environments_1.isEnvironmentSid(targetEnvironment)) {
                try {
                    const environment = yield environments_1.getEnvironmentFromSuffix(targetEnvironment, serviceSid, this.client);
                    targetEnvironment = environment.sid;
                }
                catch (err) {
                    if (activateConfig.force || activateConfig.createEnvironment) {
                        const environment = yield environments_1.createEnvironmentFromSuffix(targetEnvironment, serviceSid, this.client);
                        targetEnvironment = environment.sid;
                    }
                    else {
                        throw err;
                    }
                }
            }
            if (!buildSid && sourceEnvironment) {
                let currentEnv;
                if (!environments_1.isEnvironmentSid(sourceEnvironment)) {
                    currentEnv = yield environments_1.getEnvironmentFromSuffix(sourceEnvironment, serviceSid, this.client);
                }
                else {
                    currentEnv = yield environments_1.getEnvironment(sourceEnvironment, serviceSid, this.client);
                }
                buildSid = currentEnv.build_sid;
            }
            if (!buildSid) {
                throw new Error('Could not determine build SID');
            }
            const { domain_name } = yield environments_1.getEnvironment(targetEnvironment, serviceSid, this.client);
            yield builds_1.activateBuild(buildSid, targetEnvironment, serviceSid, this.client);
            return {
                serviceSid,
                buildSid,
                environmentSid: targetEnvironment,
                domain: domain_name,
            };
        });
    }
    /**
     * Deploys a set of functions, assets, variables and dependencies specified
     * in `deployConfig`. Functions & assets can either be paths to the local
     * filesystem or `Buffer` instances allowing you to dynamically upload
     * even without a file system.
     *
     * Unless a `deployConfig. serviceSid` is specified, it will try to create one. If a service
     * with the name `deployConfig.serviceName` already exists, it will throw
     * an error. You can make it use the existing service by setting `overrideExistingService` to
     * true.
     *
     * Updates to the deployment will be emitted as events to `status-update`. Example:
     *
     * ```js
     * client.on('status-update', ({ status, message }) => {
     *  console.log('[%s]: %s', status, message);
     * })
     * ```
     * @param  {DeployProjectConfig} deployConfig Config containing all details for deployment
     * @returns Promise<DeployResult> Object containing meta information around deployment
     */
    deployProject(deployConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = Object.assign(Object.assign({}, this.config), deployConfig);
            const { functions, assets } = config;
            let serviceSid = config.serviceSid;
            if (!serviceSid) {
                this.emit('status-update', {
                    status: consts_1.DeployStatus.CREATING_SERVICE,
                    message: 'Creating Service',
                });
                try {
                    serviceSid = yield services_1.createService(config.serviceName, this.client);
                }
                catch (err) {
                    const alternativeServiceSid = yield services_1.findServiceSid(config.serviceName, this.client);
                    if (!alternativeServiceSid) {
                        throw err;
                    }
                    if (config.overrideExistingService || config.force) {
                        serviceSid = alternativeServiceSid;
                    }
                    else {
                        const error = new Error(`Service with name "${config.serviceName}" already exists with SID "${alternativeServiceSid}".`);
                        error.name = 'conflicting-servicename';
                        Object.defineProperty(error, 'serviceSid', {
                            value: alternativeServiceSid,
                        });
                        Object.defineProperty(error, 'serviceName', {
                            value: config.serviceName,
                        });
                        throw error;
                    }
                }
            }
            this.emit('status-update', {
                status: consts_1.DeployStatus.CONFIGURING_ENVIRONMENT,
                message: `Configuring ${config.functionsEnv.length === 0 ? 'bare' : `"${config.functionsEnv}"`} environment`,
            });
            const environment = yield environments_1.createEnvironmentIfNotExists(config.functionsEnv, serviceSid, this.client);
            const { sid: environmentSid, domain_name: domain } = environment;
            //
            // Functions
            //
            this.emit('status-update', {
                status: consts_1.DeployStatus.CREATING_FUNCTIONS,
                message: `Creating ${functions.length} Functions`,
            });
            const functionResources = yield functions_1.getOrCreateFunctionResources(functions, serviceSid, this.client);
            this.emit('status-update', {
                status: consts_1.DeployStatus.UPLOADING_FUNCTIONS,
                message: `Uploading ${functions.length} Functions`,
            });
            const functionVersions = yield Promise.all(functionResources.map(fn => {
                return functions_1.uploadFunction(fn, serviceSid, this.client);
            }));
            //
            // Assets
            //
            this.emit('status-update', {
                status: consts_1.DeployStatus.CREATING_ASSETS,
                message: `Creating ${assets.length} Assets`,
            });
            const assetResources = yield assets_1.getOrCreateAssetResources(assets, serviceSid, this.client);
            this.emit('status-update', {
                status: consts_1.DeployStatus.UPLOADING_ASSETS,
                message: `Uploading ${assets.length} Assets`,
            });
            const assetVersions = yield Promise.all(assetResources.map(asset => {
                return assets_1.uploadAsset(asset, serviceSid, this.client);
            }));
            this.emit('status-update', {
                status: consts_1.DeployStatus.BUILDING,
                message: 'Waiting for deployment.',
            });
            const dependencies = dependencies_1.getDependencies(config.pkgJson);
            const build = yield builds_1.triggerBuild({ functionVersions, dependencies, assetVersions }, serviceSid, this.client);
            yield builds_1.waitForSuccessfulBuild(build.sid, serviceSid, this.client, this);
            this.emit('status-update', {
                status: consts_1.DeployStatus.SETTING_VARIABLES,
                message: 'Setting environment variables',
            });
            yield variables_1.setEnvironmentVariables(config.env, environmentSid, serviceSid, this.client);
            this.emit('status-update', {
                status: consts_1.DeployStatus.ACTIVATING_DEPLOYMENT,
                message: 'Activating deployment',
            });
            yield builds_1.activateBuild(build.sid, environmentSid, serviceSid, this.client);
            this.emit('status', {
                status: consts_1.DeployStatus.DONE,
                message: 'Project successfully deployed',
            });
            return {
                serviceSid,
                environmentSid,
                buildSid: build.sid,
                domain,
                functionResources,
                assetResources,
            };
        });
    }
    /**
     * Deploys a local project by reading existing functions and assets
     * from `deployConfig.cwd` and calling `this.deployProject` with it.
     *
     * Functions have to be placed in a `functions` or `src` directory to be found.
     * Assets have to be placed into an `assets` or `static` directory.
     *
     * Nested folder structures will result in nested routes.
     * @param  {DeployLocalProjectConfig} deployConfig
     * @returns Promise<DeployResult> Object containing meta information around deployment
     */
    deployLocalProject(deployConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            this.emit('status-update', {
                status: consts_1.DeployStatus.READING_FILESYSTEM,
                message: 'Gathering Functions and Assets to deploy',
            });
            log('Deploy config %P', deployConfig);
            const searchConfig = {};
            if (deployConfig.functionsFolderName) {
                searchConfig.functionsFolderNames = [deployConfig.functionsFolderName];
            }
            if (deployConfig.assetsFolderName) {
                searchConfig.assetsFolderNames = [deployConfig.assetsFolderName];
            }
            let { functions, assets } = yield fs_1.getListOfFunctionsAndAssets(deployConfig.cwd, searchConfig);
            if (deployConfig.noFunctions) {
                log('Disabling functions upload by emptying functions array');
                functions = [];
            }
            if (deployConfig.noAssets) {
                log('Disabling assets upload by emptying assets array');
                assets = [];
            }
            const config = Object.assign(Object.assign(Object.assign({}, this.config), deployConfig), { functions,
                assets });
            return this.deployProject(config);
        });
    }
}
exports.TwilioServerlessApiClient = TwilioServerlessApiClient;
exports.default = TwilioServerlessApiClient;
