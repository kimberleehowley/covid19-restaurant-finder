"use strict";
/** @module @twilio-labs/serverless-api/dist/api */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const querystring_1 = __importDefault(require("querystring"));
const consts_1 = require("../types/consts");
const sleep_1 = require("../utils/sleep");
const pagination_1 = require("./utils/pagination");
const log = debug_1.default('twilio-serverless-api:builds');
/**
 * Retrieves a specific build by its SID
 *
 * @export
 * @param {string} buildSid SID of build to retrieve
 * @param {string} serviceSid service to retrieve build from
 * @param {GotClient} client API client
 * @returns {Promise<BuildResource>}
 */
function getBuild(buildSid, serviceSid, client) {
    return __awaiter(this, void 0, void 0, function* () {
        const resp = yield client.get(`/Services/${serviceSid}/Builds/${buildSid}`);
        return resp.body;
    });
}
exports.getBuild = getBuild;
/**
 * Returns the current status of a build given its SID
 *
 * @param {string} buildSid the SID of the build
 * @param {string} serviceSid the SID of the service the build belongs to
 * @param {GotClient} client API client
 * @returns {Promise<BuildStatus>}
 */
function getBuildStatus(buildSid, serviceSid, client) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const resp = yield getBuild(buildSid, serviceSid, client);
            return resp.status;
        }
        catch (err) {
            log('%O', err);
            throw err;
        }
    });
}
/**
 * Returns a list of all builds related to service
 *
 * @export
 * @param {string} serviceSid the SID of the service
 * @param {GotClient} client API client
 * @returns {Promise<BuildResource[]>}
 */
function listBuilds(serviceSid, client) {
    return __awaiter(this, void 0, void 0, function* () {
        return pagination_1.getPaginatedResource(client, `/Services/${serviceSid}/Builds`);
    });
}
exports.listBuilds = listBuilds;
/**
 * Triggers a new build by creating it
 *
 * @export
 * @param {BuildConfig} config build-related information (functions, assets, dependencies)
 * @param {string} serviceSid the service to create the build for
 * @param {GotClient} client API client
 * @returns {Promise<BuildResource>}
 */
function triggerBuild(config, serviceSid, client) {
    return __awaiter(this, void 0, void 0, function* () {
        const { functionVersions, dependencies, assetVersions } = config;
        try {
            const body = {};
            if (Array.isArray(dependencies) && dependencies.length > 0) {
                const dependencyString = `"${JSON.stringify(dependencies)}"`;
                body.Dependencies = dependencyString;
            }
            if (Array.isArray(functionVersions) && functionVersions.length > 0) {
                body.FunctionVersions = functionVersions;
            }
            if (Array.isArray(assetVersions) && assetVersions.length > 0) {
                body.AssetVersions = assetVersions;
            }
            const resp = yield client.post(`/Services/${serviceSid}/Builds`, {
                // @ts-ignore
                json: false,
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: querystring_1.default.stringify(body),
            });
            return JSON.parse(resp.body);
        }
        catch (err) {
            log('%O', err);
            throw err;
        }
    });
}
exports.triggerBuild = triggerBuild;
/**
 * Resolves only when build has been completed. Will timeout after specified time.
 *
 * @export
 * @param {string} buildSid the build to wait for
 * @param {string} serviceSid the service of the build
 * @param {GotClient} client API client
 * @param {events.EventEmitter} eventEmitter optional event emitter to communicate current build status
 * @param {number} timeout optional timeout. default: 5 minutes
 * @returns {Promise<void>}
 */
function waitForSuccessfulBuild(buildSid, serviceSid, client, eventEmitter, timeout = 5 * 60 * 1000) {
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        const startTime = Date.now();
        let isBuilt = false;
        while (!isBuilt) {
            if (Date.now() - startTime > timeout) {
                if (eventEmitter) {
                    eventEmitter.emit('status-update', {
                        status: consts_1.DeployStatus.TIMED_OUT,
                        message: 'Deployment took too long',
                    });
                }
                reject(new Error('Timeout'));
            }
            const status = yield getBuildStatus(buildSid, serviceSid, client);
            isBuilt = status === 'completed';
            if (isBuilt) {
                break;
            }
            const hasFailed = status === 'failed';
            if (hasFailed) {
                reject(status);
                return;
            }
            if (eventEmitter) {
                eventEmitter.emit('status-update', {
                    status: consts_1.DeployStatus.BUILDING,
                    message: `Waiting for deployment. Current status: ${status}`,
                });
            }
            yield sleep_1.sleep(1000);
        }
        resolve();
    }));
}
exports.waitForSuccessfulBuild = waitForSuccessfulBuild;
/**
 * Activates a specific build for a given environment by creating a new deployment
 *
 * @export
 * @param {string} buildSid the build to be activated
 * @param {string} environmentSid the target environment for the build to be deployed to
 * @param {string} serviceSid the service of the project
 * @param {GotClient} client API client
 * @returns {Promise<any>}
 */
function activateBuild(buildSid, environmentSid, serviceSid, client) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const resp = yield client.post(`/Services/${serviceSid}/Environments/${environmentSid}/Deployments`, {
                form: true,
                body: {
                    BuildSid: buildSid,
                },
            });
            return resp.body;
        }
        catch (err) {
            log('%O', err);
            throw err;
        }
    });
}
exports.activateBuild = activateBuild;
