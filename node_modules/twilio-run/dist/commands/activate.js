"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const serverless_api_1 = require("@twilio-labs/serverless-api");
const check_credentials_1 = require("../checks/check-credentials");
const activate_1 = require("../config/activate");
const activate_2 = require("../printers/activate");
const logger_1 = require("../utils/logger");
const shared_1 = require("./shared");
const debug = logger_1.getDebugFunction('twilio-run:activate');
function logError(msg) {
    logger_1.logger.error(msg);
}
function handleError(err, spinner) {
    debug('%O', err);
    if (spinner) {
        spinner.fail(err.message);
    }
    process.exit(1);
}
function handler(flags, externalCliOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        logger_1.setLogLevelByName(flags.logLevel);
        let config;
        try {
            config = yield activate_1.getConfigFromFlags(flags, externalCliOptions);
        }
        catch (err) {
            debug(err);
            logError(err.message);
            process.exit(1);
            return;
        }
        if (!config) {
            logError('Internal Error');
            process.exit(1);
            return;
        }
        check_credentials_1.checkConfigForCredentials(config);
        activate_2.printActivateConfig(config);
        const details = config.buildSid
            ? `(${config.buildSid})`
            : `from ${config.sourceEnvironment}`;
        const spinner = logger_1.getOraSpinner(`Activating build ${details} to ${config.targetEnvironment || 'production'}`).start();
        try {
            const client = new serverless_api_1.TwilioServerlessApiClient(config);
            const result = yield client.activateBuild(config);
            spinner.succeed(`Activated new build ${details} on ${config.targetEnvironment ||
                'production'}`);
            activate_2.printActivateResult(result);
        }
        catch (err) {
            handleError(err, spinner);
        }
    });
}
exports.handler = handler;
exports.cliInfo = {
    options: Object.assign(Object.assign({}, shared_1.sharedCliOptions), { 'service-sid': {
            type: 'string',
            describe: 'SID of the Twilio Serverless Service to deploy to',
        }, 'build-sid': {
            type: 'string',
            alias: 'from-build',
            describe: 'An existing Build SID to deploy to the new environment',
        }, 'source-environment': {
            type: 'string',
            alias: 'from',
            describe: 'SID or suffix of an existing environment you want to deploy from.',
        }, environment: {
            type: 'string',
            alias: 'to',
            describe: 'The environment suffix or SID to deploy to.',
        }, production: {
            type: 'boolean',
            describe: 'Promote build to the production environment (no domain suffix). Overrides environment flag',
        }, 'account-sid': {
            type: 'string',
            alias: 'u',
            describe: 'A specific account SID to be used for deployment. Uses fields in .env otherwise',
        }, 'auth-token': {
            type: 'string',
            describe: 'Use a specific auth token for deployment. Uses fields from .env otherwise',
        }, 'create-environment': {
            type: 'boolean',
            describe: "Creates environment if it couldn't find it.",
            default: false,
        }, force: {
            type: 'boolean',
            describe: 'Will run deployment in force mode. Can be dangerous.',
            default: false,
        }, env: {
            type: 'string',
            describe: 'Path to .env file for environment variables that should be installed',
        } }),
};
function optionBuilder(yargs) {
    yargs = yargs
        .example('$0 promote --environment=prod --source-environment=dev  ', 'Promotes the same build that is on the "dev" environment to the "prod" environment')
        .example('$0 promote --to=prod --from=dev  ', 'Promotes the same build that is on the "dev" environment to the "prod" environment')
        .example('$0 promote --environment=demo --create-environment --build-sid=ZB1234xxxxxxxxxx', 'Duplicates an existing build to a new environment called `demo`')
        .example('$0 promote --to=demo --create-environment --from-build=ZB1234xxxxxxxxxx', 'Duplicates an existing build to a new environment called `demo`');
    yargs = Object.keys(exports.cliInfo.options).reduce((yargs, name) => {
        return yargs.option(name, exports.cliInfo.options[name]);
    }, yargs);
    return yargs;
}
exports.command = ['promote', 'activate'];
exports.describe = 'Promotes an existing deployment to a new environment';
exports.builder = optionBuilder;
