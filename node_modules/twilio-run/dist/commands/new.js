"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const inquirer_1 = __importDefault(require("inquirer"));
const path_1 = __importDefault(require("path"));
const project_structure_1 = __importDefault(require("../checks/project-structure"));
const actions_1 = require("../templating/actions");
const logger_1 = require("../utils/logger");
const shared_1 = require("./shared");
const utils_1 = require("./utils");
function getMissingInfo(flags) {
    return __awaiter(this, void 0, void 0, function* () {
        const questions = [];
        if (!flags.template) {
            const templates = yield actions_1.fetchListOfTemplates();
            const choices = templates.map(template => {
                return {
                    name: chalk_1.default `${template.name} - {dim ${template.description}}`,
                    value: template.id,
                };
            });
            questions.push({
                type: 'list',
                name: 'template',
                message: 'Select a template',
                choices,
            });
        }
        if (!flags.namespace) {
            questions.push({
                type: 'input',
                name: 'namespace',
                message: 'What should be the namespace your function(s) are placed under?',
                validate: (input) => {
                    if (input.length < 1 || input.includes(' ')) {
                        return 'Your name cannot include whitespace';
                    }
                    return true;
                },
            });
        }
        if (questions.length === 0) {
            return Object.assign(Object.assign({}, flags), { namespace: flags.namespace, template: flags.template });
        }
        const answers = yield inquirer_1.default.prompt(questions);
        return Object.assign(Object.assign({}, flags), { template: flags.template || answers.template, namespace: flags.namespace || answers.namespace });
    });
}
function getBaseDirectoryPath() {
    const currentDir = process.cwd();
    const baseName = path_1.default.basename(currentDir);
    if (baseName === 'functions' ||
        baseName === 'assets' ||
        baseName === 'src' ||
        baseName === 'static' ||
        baseName === 'readmes') {
        return path_1.default.resolve(currentDir, '..');
    }
    return currentDir;
}
function handler(flagsInput, externalCliOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        logger_1.setLogLevelByName(flagsInput.logLevel);
        const targetDirectory = getBaseDirectoryPath();
        const command = utils_1.getFullCommand(flagsInput);
        yield project_structure_1.default(targetDirectory, command, true);
        const flags = yield getMissingInfo(flagsInput);
        if (typeof flags.namespace === 'undefined' ||
            flags.namespace.length === 0 ||
            typeof flags.template === 'undefined' ||
            flags.namespace.length === 0) {
            return;
        }
        const sanitizedNamespace = flags.namespace.replace(/\.js$/, '');
        actions_1.downloadTemplate(flags.template, sanitizedNamespace, targetDirectory);
    });
}
exports.handler = handler;
exports.cliInfo = {
    options: Object.assign(Object.assign({}, shared_1.baseCliOptions), { template: {
            type: 'string',
            description: 'Name of template to be used',
        } }),
};
function optionBuilder(yargs) {
    yargs = yargs.example('$0 new hello-world --template=blank', 'Creates a basic blank template as hello-world function');
    yargs = Object.keys(exports.cliInfo.options).reduce((yargs, name) => {
        return yargs.option(name, exports.cliInfo.options[name]);
    }, yargs);
    return yargs;
}
exports.command = ['new [namespace]', 'template [namespace]'];
exports.describe = 'Creates a new Twilio Function based on an existing template';
exports.builder = optionBuilder;
