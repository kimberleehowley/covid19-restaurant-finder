"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const ora_1 = __importDefault(require("ora"));
const stream_1 = require("stream");
const utils_1 = require("../printers/utils");
// an empty stream that immediately drops everything. Like /dev/null
const EmptyStream = new stream_1.Writable();
EmptyStream._write = (chunk, encoding, callback) => {
    setImmediate(callback);
};
exports.LoggingLevel = {
    debug: -1,
    info: 0,
    warn: 1,
    error: 2,
    none: 10,
};
class Logger {
    constructor(opts) {
        this.useDebugModule = true;
        this.options = opts;
        this.config = opts;
    }
    get config() {
        return this.options;
    }
    set config(val) {
        this.options = val;
        if (val.level === exports.LoggingLevel.debug) {
            const namespaces = ['twilio*'];
            if (process.env.DEBUG) {
                namespaces.push(process.env.DEBUG);
            }
            process.env.DEBUG = namespaces.join(',');
            debug_1.default.enable(process.env.DEBUG);
        }
    }
    debug(msg) {
        this.log(msg, exports.LoggingLevel.debug);
    }
    info(msg) {
        this.log(msg, exports.LoggingLevel.info);
    }
    warn(msg, title = '') {
        msg = utils_1.warningMessage(title, msg);
        this.log(msg, exports.LoggingLevel.warn);
    }
    error(msg, title = '') {
        msg = utils_1.errorMessage(title, msg);
        this.log(msg, exports.LoggingLevel.error);
    }
    log(msg, level) {
        level = level || exports.LoggingLevel.info;
        if (level >= this.config.level) {
            const message = typeof msg === 'string' ? msg : JSON.stringify(msg);
            process.stderr.write(message + '\n');
        }
    }
}
exports.Logger = Logger;
function getDebugFunction(namespace) {
    const debugLogger = debug_1.default(namespace);
    if (!exports.logger.useDebugModule) {
        debugLogger.enabled = true;
        debug_1.default.log = exports.logger.debug.bind(exports.logger);
    }
    return debugLogger;
}
exports.getDebugFunction = getDebugFunction;
function setLogLevelByName(name) {
    exports.logger.config = { level: exports.LoggingLevel[name] };
}
exports.setLogLevelByName = setLogLevelByName;
function getOraSpinner(options) {
    let oraOptions;
    if (typeof options === 'string') {
        oraOptions = {
            text: options,
        };
    }
    else if (typeof options === 'undefined') {
        oraOptions = {};
    }
    else {
        oraOptions = options;
    }
    if (exports.logger.config.level > exports.LoggingLevel.info) {
        oraOptions = Object.assign(Object.assign({}, oraOptions), { 
            // write to a stream that drops the content
            stream: EmptyStream });
    }
    return ora_1.default(oraOptions);
}
exports.getOraSpinner = getOraSpinner;
exports.logger = new Logger({
    level: exports.LoggingLevel.info,
});
function overrideLogger(newLogger) {
    exports.logger = newLogger;
}
exports.overrideLogger = overrideLogger;
